//SPDX-FileCopyrightText: 2023 Matthew Millard millard.matthew@gmail.com
//SPDX-License-Identifier: MIT

#include <cstdio>
#include <fstream>
#include <string>

#include <nlohmann/json.hpp>
#include <tclap/CmdLine.h>

#include <filesystem>

#include "JsonFunctions.h"
#include "FinancialAnalysisFunctions.h"

struct CountryExchangeData {
  std::vector< std::string > exchanges;
  unsigned int count;  
  std::string countryISO2;
  std::string countryISO3;
  std::string name;
};


int main (int argc, char* argv[]) {

  std::string exchangeCode;
  std::string fundamentalFolder;
  std::string exchangeListFileName;  
  std::string outputFolder;
  bool verbose;

  try{
    TCLAP::CmdLine cmd("The command will scan a folder containing fundamental "
    "data (from https://eodhistoricaldata.com/) and will report a summary of "
    "each ticker within the folder along with the results of checks of data "
    "consistency."
    ,' ', "0.0");




    TCLAP::ValueArg<std::string> fundamentalFolderInput("f",
      "fundamental_data_folder_path", 
      "The path to the folder that contains the fundamental data json files from "
      "https://eodhistoricaldata.com/ to analyze",
      true,"","string");

    cmd.add(fundamentalFolderInput);

    TCLAP::ValueArg<std::string> exchangeCodeInput("x","EXCHANGE_CODE", 
      "The exchange code. For example: US",
      true,"","string");

    cmd.add(exchangeCodeInput);  

    TCLAP::ValueArg<std::string> outputFolderInput("o","output_folder_path", 
      "The path to the folder that will contain the output json files "
      "produced by this analysis",
      true,"","string");

    cmd.add(outputFolderInput);

    TCLAP::ValueArg<std::string> exchangeListFileNameInput("l","exchange_list", 
      "The exchanges.json file generated by EOD",
      true,"","string");

    cmd.add(exchangeListFileNameInput);     

    TCLAP::SwitchArg verboseInput("v","verbose",
      "Verbose output printed to screen", false);
    cmd.add(verboseInput);    

    cmd.parse(argc,argv);

    fundamentalFolder         = fundamentalFolderInput.getValue();
    exchangeCode              = exchangeCodeInput.getValue();  
    outputFolder              = outputFolderInput.getValue();
    exchangeListFileName      = exchangeListFileNameInput.getValue(); 
    verbose                   = verboseInput.getValue();


    if(verbose){
      std::cout << "  Fundamental Data Folder" << std::endl;
      std::cout << "    " << fundamentalFolder << std::endl;
      
      std::cout << "  Exchange Code" << std::endl;
      std::cout << "    " << exchangeCode << std::endl;

      std::cout << "  Exchange List File" << std::endl;
      std::cout << "    " << exchangeListFileName << std::endl;

      std::cout << "  Output Folder" << std::endl;
      std::cout << "    " << outputFolder << std::endl;
    }
  } catch (TCLAP::ArgException &e)  // catch exceptions
	{ 
    std::cerr << "error: "    << e.error() 
              << " for arg "  << e.argId() << std::endl; 
  }

  std::vector< CountryExchangeData > vectorCountryExchangeData;

  //load the exchange-list
  using json = nlohmann::ordered_json;  
  std::ifstream exchangeListFileStream(exchangeListFileName.c_str());
  json exchangeList = json::parse(exchangeListFileStream);

  std::string validFileExtension = exchangeCode;
  validFileExtension.append(".json");

  auto startingDirectory = std::filesystem::current_path();
  std::filesystem::current_path(fundamentalFolder);

  unsigned int count=0;
  unsigned int errorCount=0;

  using json = nlohmann::ordered_json;
  json scanResults;

  //Get a list of the json files in the input folder
  for ( const auto & entry 
          : std::filesystem::directory_iterator(fundamentalFolder)){

    //Check to see if the input json file is valid and is for the primary
    //ticker

    bool validInput = false;

    std::string fileName=entry.path().filename();
    size_t lastIndex = fileName.find_last_of(".");
    std::size_t foundExtension = fileName.find(validFileExtension);

    if( foundExtension != std::string::npos ){
        validInput=true;                                                                 
    }

      
    //Process the file if its valid;
    if(validInput){
      //Load the json file
      std::stringstream ss;
      ss << fundamentalFolder << fileName;
      std::string filePathName = ss.str();
      std::ifstream inputJsonFileStream(filePathName.c_str());
      json jsonData = json::parse(inputJsonFileStream);

      std::string name("");
      std::string code("");
      std::string primaryTicker("");      
      std::string exchange("");
      std::string currencyCode("");
      std::string currencySymbol("");
      std::string isin("");
      bool primaryTickerMissing=false;
      bool currencySymbolMissing=false;
      bool isinMissing = false;

    

      JsonFunctions::getJsonString(jsonData[GEN]["Name"], name);
      JsonFunctions::getJsonString(jsonData[GEN]["Code"], code);

      //The spelling of ISIN in the json files is not always consistent      
      JsonFunctions::getJsonString(jsonData[GEN]["ISIN"], isin);
      if(isin.length()==0){
        JsonFunctions::getJsonString(jsonData[GEN]["Isin"], isin);
      }
      if(isin.length()==0){
        JsonFunctions::getJsonString(jsonData[GEN]["isin"], isin);
      }

      JsonFunctions::getJsonString(jsonData[GEN]["PrimaryTicker"], primaryTicker);
      JsonFunctions::getJsonString(jsonData[GEN]["Exchange"], exchange);
      JsonFunctions::getJsonString(jsonData[GEN]["CurrencyCode"], currencyCode);
      

      if(currencyCode.length()==0){
        currencySymbolMissing = true;
      }

      if(primaryTicker.length()==0){
        primaryTickerMissing = true;
      }

      if(isin.length()==0){
        isinMissing = true;
      }

      //Use the ISIN to locate the company's country and exchange and
      //store this information
      if(!isinMissing){
        std::string isinCountryISO2("");
        std::string isinCountryISO3("");

        FinancialAnalysisFunctions::
          getIsinCountryCodes(isin, exchangeList,isinCountryISO2,isinCountryISO3);

        bool countryCodeFound=false;
        auto iterCountry=vectorCountryExchangeData.begin();
        while(!countryCodeFound && 
          iterCountry != vectorCountryExchangeData.end()){

            if(  (*iterCountry).countryISO2.compare(isinCountryISO2) == 0 
              && (*iterCountry).countryISO3.compare(isinCountryISO3) == 0){
                (*iterCountry).count = (*iterCountry).count+1;
                countryCodeFound=true;
              }
            ++iterCountry;
        }

        //If this is the first entry for this country populate all fields
        if(!countryCodeFound){
          CountryExchangeData countryExchData;
          countryExchData.countryISO2=isinCountryISO2;
          countryExchData.countryISO3=isinCountryISO3;
          countryExchData.count = 1;

          //Now loop through the exchange list file and add the codes for 
          //all of the exchanges that are in this country
          for(auto& iterScan : exchangeList ){
            std::string countryISO2=iterScan["CountryISO2"].get<std::string>();
            std::string countryISO3=iterScan["CountryISO3"].get<std::string>();            

            if(    isinCountryISO2.compare(countryISO2) == 0 
                && isinCountryISO3.compare(countryISO3) == 0 ){ 
                std::string code = iterScan["Code"].get<std::string>();
              countryExchData.exchanges.push_back(code);            
              countryExchData.name = iterScan["Country"].get<std::string>();
            }
          }
          vectorCountryExchangeData.push_back(countryExchData);                 
        }
        

      }

      if(verbose && (currencySymbolMissing || primaryTickerMissing || isinMissing)){
        ++errorCount;
        std::cout   << errorCount << ". Missing: ";

        if(primaryTickerMissing){
          std::cout   << "PrimaryTicker " ;
        }
        if(isinMissing){
          std::cout   << "ISIN " ;
        }
        if(currencySymbolMissing){
          std::cout   << "CurrencySymbol " ;
        }

        std::cout << fileName << " " << exchange << " " << name << std::endl;

      }

      json tickerEntry = json::object( 
                        { 
                          {"Code", code},
                          {"Name", name},
                          {"Exchange", exchange},
                          {"ISIN",isin},
                          {"PrimaryTicker", primaryTicker},
                          {"CurrencyCode", currencyCode},
                          {"currency_symbol", currencySymbol},
                          {"MissingISIN", isinMissing},
                          {"MissingPrimaryTicker", primaryTickerMissing},
                          {"MissingCurrencySymbol", currencySymbolMissing},
                        }
                      );

      scanResults[code]= tickerEntry;

    }

    ++count;
  }

  //Translate the CountryExchangeData vector into a JSON file
  std::vector < unsigned int > vectorCount;
  std::vector < unsigned int > vectorIndex;

  vectorCount.resize(vectorCountryExchangeData.size());
  vectorIndex.resize(vectorCountryExchangeData.size());

  for(size_t i = 0; i < vectorCountryExchangeData.size(); ++i){
    vectorCount[i] = vectorCountryExchangeData[i].count;
    vectorIndex[i] = i;
  }  
  //Now sort
  sort(vectorIndex.begin(), vectorIndex.end(),
        [&](const int& a, const int& b){
            return(vectorCount[a] > vectorCount[b]);
        }
      );

  json countryExchangeList;
  for(unsigned int i =0; i < vectorIndex.size(); i++){
    unsigned int idx = vectorIndex[i];
    std::string exchangeList("");    
    for(unsigned int j=0; j<vectorCountryExchangeData[idx].exchanges.size();++j){
      exchangeList.append(vectorCountryExchangeData[idx].exchanges[j]);
      if(j < vectorCountryExchangeData[idx].exchanges.size()-1){
        exchangeList.append(", ");
      }
    }

    json countryExchangeEntry = json::object(
      {
        {"Country", vectorCountryExchangeData[idx].name},
        {"Code" , exchangeList},
        {"CountryISO2", vectorCountryExchangeData[idx].countryISO2},
        {"CountryISO3", vectorCountryExchangeData[idx].countryISO3},        
        {"Count", vectorCountryExchangeData[idx].count},
      }
    );

    countryExchangeList.emplace_back(countryExchangeEntry);
  }

  //Output the results to file

  //Scan results
  std::string outputFilePath(outputFolder);
  std::string outputFileName(exchangeCode);

  outputFileName.append(".");
  outputFileName.append("scan");
  outputFileName.append(".json");
  
  //Update the extension 
  outputFilePath.append(outputFileName);

  std::ofstream outputFileStream(outputFilePath,
      std::ios_base::trunc | std::ios_base::out);
  outputFileStream << scanResults;
  outputFileStream.close();

  //Country-Exchange-Ticker results
  outputFileName=exchangeCode;
  outputFileName.append(".scan.country_count_by_isin.json");

  outputFilePath = outputFolder;
  outputFilePath.append(outputFileName);

  outputFileStream.open(outputFilePath,
    std::ios_base::trunc | std::ios_base::out);
  outputFileStream << countryExchangeList;
  outputFileStream.close();

  std::cout << "success" << std::endl;

  return 0;
}
