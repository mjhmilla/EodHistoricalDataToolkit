
#include <cstdio>
#include <fstream>
#include <string>

#include <nlohmann/json.hpp>
#include <tclap/CmdLine.h>

#include <filesystem>

#include "FinancialAnalysisToolkit.h"

unsigned int COLUMN_WIDTH = 30;

struct primaryTickerPatchData {
  std::string currency;
  std::vector< std::string > exchanges;
  std::vector< std::string > tickersInError;
  std::vector< bool > patchFound;
};

int main (int argc, char* argv[]) {

  std::string exchangeCode;
  std::string fundamentalFolder;
  std::string exchangeListFileName;
  std::string exchangeSymbolListFolder;
  std::string outputFolder;
  bool verbose;

  try{
    TCLAP::CmdLine cmd("The command will scan a folder containing fundamental "
    "data (from https://eodhistoricaldata.com/) and will report entries "
    "that appear to be in error. For example, a company that is on a German"
    "exchange, that does its accounting in USD, yet does not have a "
    "primary ticker entry is probably in error. If additional information addded "
    "(the exchange list, and exchange-symbol-lists) these files will be scanned for"
    "for a potential patch to fix missing PrimaryTicker fields. The "
    "results of the scan appear in the output json file."
    ,' ', "0.0");




    TCLAP::ValueArg<std::string> fundamentalFolderInput("f",
      "fundamental_data_folder_path", 
      "The path to the folder that contains the fundamental data json files from "
      "https://eodhistoricaldata.com/ to analyze",
      true,"","string");

    cmd.add(fundamentalFolderInput);

    TCLAP::ValueArg<std::string> exchangeCodeInput("x","EXCHANGE_CODE", 
      "The exchange code. For example: US",
      true,"","string");

    cmd.add(exchangeCodeInput);  


    TCLAP::ValueArg<std::string> exchangeSymbolListFolderInput("s",
      "exchange_symbol_list", "A folder that contains json files, one per "
      "exchange, that lists the tickers in each exchange",
      false,"","string");


    cmd.add(exchangeSymbolListFolderInput);  

    TCLAP::ValueArg<std::string> exchangeListFileNameInput("l","exchange_list", 
      "The exchanges-list json file generated by EOD",
      false,"","string");

    cmd.add(exchangeListFileNameInput); 

    TCLAP::ValueArg<std::string> outputFolderInput("o","output_folder_path", 
      "The path to the folder that will contain the output json files "
      "produced by this analysis",
      true,"","string");

    cmd.add(outputFolderInput);

    TCLAP::SwitchArg verboseInput("v","verbose",
      "Verbose output printed to screen", false);
    cmd.add(verboseInput);    

    cmd.parse(argc,argv);

    fundamentalFolder         = fundamentalFolderInput.getValue();
    exchangeCode              = exchangeCodeInput.getValue();
    exchangeListFileName      = exchangeListFileNameInput.getValue(); 
    exchangeSymbolListFolder  = exchangeSymbolListFolderInput.getValue();   
    outputFolder              = outputFolderInput.getValue();
    verbose                   = verboseInput.getValue();

    //Both or neigther of these variables should be set:
    //  exchangeListFileName,  exchangeSymbolListFolder.
    if(    (  exchangeListFileName.length()      > 0 
           && exchangeSymbolListFolder.length() == 0) 
        || (  exchangeListFileName.length()     == 0 
           && exchangeSymbolListFolder.length()  > 0)){
      throw std::invalid_argument(
        "Both or neither of these two tickers must be set: exchange_list (-l) "
        "and exchange_symbol_list (-s).");               
    }

    if(verbose){
      std::cout << "  Fundamental Data Folder" << std::endl;
      std::cout << "    " << fundamentalFolder << std::endl;
      
      std::cout << "  Exchange Code" << std::endl;
      std::cout << "    " << exchangeCode << std::endl;

      std::cout << "  Exchange List File" << std::endl;
      std::cout << "    " << exchangeListFileName << std::endl;

      std::cout << "  Exchange Symbol List" << std::endl;
      std::cout << "    " << exchangeSymbolListFolder << std::endl;

      std::cout << "  Output Folder" << std::endl;
      std::cout << "    " << outputFolder << std::endl;
    }
  } catch (TCLAP::ArgException &e)  // catch exceptions
	{ 
    std::cerr << "error: "    << e.error() 
              << " for arg "  << e.argId() << std::endl; 
  }


  std::string validFileExtension = exchangeCode;
  validFileExtension.append(".json");

  auto startingDirectory = std::filesystem::current_path();
  std::filesystem::current_path(fundamentalFolder);

  unsigned int count=0;
  unsigned int errorCount=0;

  using json = nlohmann::ordered_json;
  json scanResults;

  //Get a list of the json files in the input folder
  for ( const auto & entry 
          : std::filesystem::directory_iterator(fundamentalFolder)){

    //Check to see if the input json file is valid and is for the primary
    //ticker

    bool validInput = false;

    std::string fileName=entry.path().filename();
    size_t lastIndex = fileName.find_last_of(".");
    std::size_t foundExtension = fileName.find(validFileExtension);

    if( foundExtension != std::string::npos ){
        validInput=true;                                                                 
    }

      
    //Process the file if its valid;
    if(validInput){
      //Load the json file
      std::stringstream ss;
      ss << fundamentalFolder << fileName;
      std::string filePathName = ss.str();
      std::ifstream inputJsonFileStream(filePathName.c_str());
      json jsonData = json::parse(inputJsonFileStream);

      std::string name("");
      std::string code("");
      std::string primaryTicker("");      
      std::string exchange("");
      std::string currencyCode("");
      std::string currencySymbol("");
      bool primaryTickerMissing=false;
      bool currencySymbolMissing=false;


    

      FinancialAnalysisToolkit::
        getJsonString(jsonData[GEN]["Name"], name);
      FinancialAnalysisToolkit::
        getJsonString(jsonData[GEN]["Code"], code);
      FinancialAnalysisToolkit::
        getJsonString(jsonData[GEN]["PrimaryTicker"], primaryTicker);
      FinancialAnalysisToolkit::
        getJsonString(jsonData[GEN]["Exchange"], exchange);
      FinancialAnalysisToolkit::
        getJsonString(jsonData[GEN]["CurrencyCode"], currencyCode);


      auto it= jsonData[FIN][BAL][Q].begin();

      if(it != jsonData[FIN][BAL][Q].end()){
        FinancialAnalysisToolkit::
          getJsonString(
              jsonData[FIN][BAL][Q][it.key().c_str()]["currency_symbol"], 
              currencySymbol);
      }else{
        currencySymbolMissing=true;
      }

      if(verbose && currencySymbolMissing){
        ++errorCount;
        std::cout << errorCount  
          << ". Missing: [Financials][Balance_Sheet][currency_symbol] "
          << std::endl << "    "
          <<  fileName << " " << exchange << " " << name <<  std::endl;
      }


      if(currencySymbol.compare(currencyCode) != 0 
          && currencySymbolMissing==false){
        if(primaryTicker.length()==0){
          primaryTickerMissing = true;
        }
      }

      if(verbose && primaryTickerMissing){
        ++errorCount;
        std::cout   << errorCount 
                    << ". Missing: PrimaryTicker " << std::endl  
                    << "    " 
                    << fileName << " " << exchange << " " << name << std::endl;
      }

      json tickerEntry = json::object( 
                        { 
                          {"Code", code},
                          {"Name", name},
                          {"Exchange", exchange},
                          {"PrimaryTicker", primaryTicker},
                          {"CurrencyCode", currencyCode},
                          {"currency_symbol", currencySymbol},
                          {"MissingPrimaryTicker", primaryTickerMissing},
                          {"MissingCurrencySymbol", currencySymbolMissing},
                          {"PrimaryTickerPatch", ""},
                        }
                      );

      scanResults[code]= tickerEntry;

    }

    ++count;
  }

  //Scan the list of exhanges for potential patches
  if(exchangeSymbolListFolder.length() > 0 && exchangeListFileName.length()>0){
    if(verbose){
      std::cout << std::endl;
      std::cout << "Scanning exchange-symbol-lists for companies " << std::endl;
      std::cout << "with the same name. These are stored as a" << std::endl;
      std::cout << "potential PrimaryTickerPatch" << std::endl;
    }

    //load the exchange-list
    std::ifstream exchangeListFileStream(exchangeListFileName.c_str());
    json exchangeList = json::parse(exchangeListFileStream);

    //scan the errors and group them by currency
    std::vector< primaryTickerPatchData > primaryTickerPatchDataVector;

    unsigned int patchCount = 0;

    for(auto& i : scanResults){

      if(i["MissingPrimaryTicker"].get<bool>()){

        std::string currency_symbol;
        FinancialAnalysisToolkit::
          getJsonString(i["currency_symbol"],currency_symbol);

        bool appendNewPatchData=true;
        for(auto& j : primaryTickerPatchDataVector){
          //If the currency exists, then add to the existing patch
          if( j.currency.compare(currency_symbol)==0){
            appendNewPatchData=false;
            std::string code;
            FinancialAnalysisToolkit:: 
              getJsonString(i["Code"],code);            
            j.tickersInError.push_back(code);
            j.patchFound.push_back(false);
          }
        }

        //If the currency doesn't exist, then make a new entry
        if(appendNewPatchData){
          primaryTickerPatchData patch;
          patch.currency = currency_symbol;

          std::string code;
          FinancialAnalysisToolkit:: 
            getJsonString(i["Code"],code);            
          patch.tickersInError.push_back(code);
          patch.patchFound.push_back(false);
          for(auto& k : exchangeList){
            std::string exchangeCurrency;
            FinancialAnalysisToolkit:: 
              getJsonString(k["Currency"],exchangeCurrency);
              if(patch.currency.compare(exchangeCurrency)==0){
                std::string exchangeCode;
                FinancialAnalysisToolkit:: 
                  getJsonString(k["Code"],exchangeCode);
                patch.exchanges.push_back(exchangeCode);
              }
          }
          primaryTickerPatchDataVector.push_back(patch);
        }
      }
    }

    //The data in primaryTickerPatchDataVector has been organized so that
    //the file for a specific exchange only needs to be opened once to 
    //reduce the run time.
    for (auto& itPatchData : primaryTickerPatchDataVector){
      for (auto& itExchange : itPatchData.exchanges ){
        //load the exchange-symbol-list
        std::string exchangeSymbolListPath = exchangeSymbolListFolder;
        exchangeSymbolListPath.append(itExchange);
        exchangeSymbolListPath.append(".json");
        std::ifstream exchangeSymbolListFileStream(exchangeSymbolListPath);
        json exchangeSymbolList = json::parse(exchangeSymbolListFileStream);        

        //for(auto& itTicker : itPatchData.tickersInError){
        for(unsigned int itTicker=0; 
                         itTicker<itPatchData.tickersInError.size();++itTicker){
          bool nameFound = false;
          std::string name;
          std::string tickerName = itPatchData.tickersInError[itTicker];
          FinancialAnalysisToolkit::
            getJsonString(scanResults[tickerName]["Name"],name);

          std::string sym;
          for(auto& itSym : exchangeSymbolList){
            FinancialAnalysisToolkit::getJsonString(itSym["Name"],sym);
            if(name.compare(sym)==0){
              nameFound=true;
              std::string eodCode;
              std::string ex;
              FinancialAnalysisToolkit::getJsonString(itSym["Code"],eodCode);
              eodCode.append(".");
              eodCode.append(itExchange);
              scanResults[tickerName]["PrimaryTickerPatch"] = eodCode;
              itPatchData.patchFound[itTicker]=true;
              if(verbose){
                ++patchCount;
                std::string code;
                FinancialAnalysisToolkit::
                  getJsonString(scanResults[tickerName]["Code"],code);                
                std::cout   << patchCount 
                    << ".  " << code << " " << name << std::endl  
                    << "    " << "PrimaryTickerPatch: " 
                    << sym << " (" << eodCode << ")" << std::endl;
              }

              break;
            }
          }
        }

      }
    }
    //Report on the items that were patched and not.
    if(verbose){
      std::cout << std::endl;
      std::cout << "Patches could not be found for : " << std::endl;
      unsigned int  countMissingPatches = 0;
      for(auto& itData : primaryTickerPatchDataVector){
        for(unsigned int i=0; i<itData.patchFound.size();++i){
          if(itData.patchFound[i]==false){
            std::string name("");
            FinancialAnalysisToolkit::
              getJsonString(scanResults[itData.tickersInError[i]]["Name"],name);
            ++countMissingPatches;
            std::cout << countMissingPatches 
                << ".  " << itData.tickersInError[i] 
                << " (" << name << ")" << std::endl;
            std::cout << "     " << itData.currency << ": ";
            for(unsigned int j=0; j<itData.exchanges.size();++j){
              std::cout << itData.exchanges[j] << " " ;
            }
            std::cout << std::endl;
          }
        }
      }
    }
    
  }


  std::string outputFilePath(outputFolder);
  std::string outputFileName("scan");
  outputFileName.append(".");
  outputFileName.append(exchangeCode);
  outputFileName.append(".json");
  
  //Update the extension 
  outputFilePath.append(outputFileName);

  std::ofstream outputFileStream(outputFilePath,
      std::ios_base::trunc | std::ios_base::out);
  outputFileStream << scanResults;
  outputFileStream.close();

  std::cout << "success" << std::endl;

  return 0;
}
