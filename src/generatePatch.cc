
#include <cstdio>
#include <fstream>
#include <string>


#include <nlohmann/json.hpp>
#include <tclap/CmdLine.h>

#include <filesystem>

#include "JsonFunctions.h"
#include "StringToolkit.h"


struct primaryTickerPatchData {
  std::string currency;
  std::vector< std::string > exchanges;
  std::vector< std::string > tickersInError;
  std::vector< bool > patchFound;
};


const double MIN_MATCHING_WORD_FRACTION = 0.3;


int main (int argc, char* argv[]) {

  std::string exchangeCode;
  std::string scanFileName;
  std::string exchangeListFileName;
  std::string mainExchangeListFileName;
  std::string exchangeSymbolListFolder;
  std::string outputFolder;
  bool verbose;

  try{
    TCLAP::CmdLine cmd("The command will read the output from the scan "
    "function and will try to find patches for the problems identified "
    "by scan. For example, a company that is on a German "
    "exchange, but has an ISIN from another country, its PrimaryTicker should"
    "also be from that country. If the ISIN is missing, the currency used for "
    "accounting should be the currency of the exchange listed in the "
    "PrimaryTicker. If these consistency checks fail, then the appropriate"
    "exchange-symbol-lists to find either a company with a matching ISIN, "
    "or a company with a very similar name."
    ,' ', "0.0");




    TCLAP::ValueArg<std::string> scanFileNameInput("c",
      "scan_file_name", 
      "The full path and file name for the file produced by the scan "
      "function (e.g. STU.scan.json).",
      true,"","string");

    cmd.add(scanFileNameInput);

    TCLAP::ValueArg<std::string> exchangeCodeInput("x","exchange_code", 
      "The exchange code. For example: US",
      true,"","string");

    cmd.add(exchangeCodeInput);  

    TCLAP::ValueArg<std::string> exchangeSymbolListFolderInput("s",
      "exchange_symbol_list", "A folder that contains json files, one per "
      "exchange, that lists the tickers in each exchange",
      true,"","string");


    cmd.add(exchangeSymbolListFolderInput);  

    TCLAP::ValueArg<std::string> exchangeListFileNameInput("l","exchange_list", 
      "The exchanges-list json file generated by EOD",
      true,"","string");

    cmd.add(exchangeListFileNameInput); 

    TCLAP::ValueArg<std::string> mainExchangeListFileNameInput("m","main_exchange_list", 
      "The main/largest exchange for this country. For example, in Germany the "
      "Frankfurt Exchange is the largest and can be used as a reference for "
      "entries that are missing in the smaller exchanges in Germany "
      "(e.g. Stuttgart)",
      false,"","string");

    cmd.add(mainExchangeListFileNameInput);  


    TCLAP::ValueArg<std::string> outputFolderInput("o","output_folder_path", 
      "The path to the folder that will contain the output json files "
      "produced by this analysis",
      true,"","string");

    cmd.add(outputFolderInput);

    TCLAP::SwitchArg verboseInput("v","verbose",
      "Verbose output printed to screen", false);
    cmd.add(verboseInput);    

    cmd.parse(argc,argv);

    scanFileName              = scanFileNameInput.getValue();
    exchangeCode              = exchangeCodeInput.getValue();
    mainExchangeListFileName  = mainExchangeListFileNameInput.getValue();
    exchangeListFileName      = exchangeListFileNameInput.getValue(); 
    exchangeSymbolListFolder  = exchangeSymbolListFolderInput.getValue();   
    outputFolder              = outputFolderInput.getValue();
    verbose                   = verboseInput.getValue();

    if(verbose){
      std::cout << "  Scan File Name" << std::endl;
      std::cout << "    " << scanFileName << std::endl;
      
      std::cout << "  Exchange Code" << std::endl;
      std::cout << "    " << exchangeCode << std::endl;

      std::cout << "  Exchange List File" << std::endl;
      std::cout << "    " << exchangeListFileName << std::endl;

      std::cout << "  Main Exchange List File" << std::endl;
      std::cout << "    " << mainExchangeListFileName << std::endl;

      std::cout << "  Exchange Symbol List" << std::endl;
      std::cout << "    " << exchangeSymbolListFolder << std::endl;

      std::cout << "  Output Folder" << std::endl;
      std::cout << "    " << outputFolder << std::endl;
    }
  } catch (TCLAP::ArgException &e)  // catch exceptions
	{ 
    std::cerr << "error: "    << e.error() 
              << " for arg "  << e.argId() << std::endl; 
  }


  std::string validFileExtension = exchangeCode;
  validFileExtension.append(".json");



  unsigned int count=0;
  unsigned int errorCount=0;

  using json = nlohmann::ordered_json;
  std::ifstream scanFileStream(scanFileName.c_str());
  json scanResults = json::parse(scanFileStream);

  json patchResults;

  //Scan the list of exhanges for potential patches
  if(verbose){
    std::cout << std::endl;
    std::cout << "Scanning exchange-symbol-lists for companies "    <<std::endl;
    std::cout << "with the same ISIN. If the ISIN is not available" <<std::endl;
    std::cout << " a company with a similar name is searched. "     <<std::endl;
    std::cout << "Patches are stored in separate files depending " << std::endl;
    std::cout << " on the type of match that has been made. " << std::endl;
  }

  //load the exchange-list
  std::ifstream exchangeListFileStream(exchangeListFileName.c_str());
  json exchangeList = json::parse(exchangeListFileStream);

  //load the main-exchange-list
  json mainExchangeList;
  bool mainExchangeAvailable=false;
  if(mainExchangeListFileName.length()>0){
    std::ifstream mainExchangeListFileStream(mainExchangeListFileName.c_str());
    mainExchangeList = json::parse(mainExchangeListFileStream);
    mainExchangeAvailable=true;
  }

  //scan the errors and group them by currency
  std::vector< primaryTickerPatchData > primaryTickerPatchDataVector;

  unsigned int patchCount = 0;


  //1. Sort MissingPrimaryTicker errors by currency.
  //2. Identify the exchanges that use that currency
  //3. Then use this list to look for matching company names so that you 
  //   only have to open each exchange symbol list once.
  for(auto& iterScan : scanResults){

    //Patch the ISIN from the main exchange, if its available
    std::string isin=iterScan["ISIN"].get<std::string>();
    if(isin.length()==0){
      if(mainExchangeAvailable){
        auto iterExchange=mainExchangeList.begin();
        bool found=false;

        while(iterExchange != mainExchangeList.end() && !found){
          if( iterScan["Name"].get<std::string>().compare( 
              (*iterExchange)["Name"].get<std::string>()) == 0 ){
            isin = (*iterExchange)["Isin"].get<std::string>(); 
            found=true;
          }
          ++iterExchange;
        }
      }
    }

    if(iterScan["MissingPrimaryTicker"].get<bool>()){
     
      json patchEntry = 
        json::object( 
            { 
              {"Code", iterScan["Code"].get<std::string>()},
              {"Name", iterScan["Name"].get<std::string>()},
              {"Exchange", iterScan["Exchange"].get<std::string>()},
              {"ISIN", isin},
              {"PrimaryTicker", iterScan["PrimaryTicker"].get<std::string>()},
              {"PatchFound",false},
              {"PatchPrimaryTicker", ""},
              {"PatchPrimaryExchange", ""},
              {"PatchName",""},
              {"PatchISIN",""},
              {"PatchISINExactMatch",false},
              {"PatchNameSimilarityScore",0.},
              {"PatchNameExactMatch",false},
              {"PatchNameClosest",""},
              {"PatchCodeClosest",""},
              {"PatchExchangeClosest",""},
              {"PatchISINClosest",""},
              {"PatchNameSimilarityScoreClosest",0.},
            }
          );



      patchResults[iterScan["Code"].get<std::string>()]= patchEntry;

      //Retrieve the company's domestic currency
      std::string currency;
      

      //If the isin exists, use the first digits to directly find the
      //exchanges that carry this symbol. Directly retrieve the currency
      //for the exchange.
      if(isin.length()>0){
        auto iterExchange=exchangeList.begin();
        bool found=false;

        while(iterExchange != exchangeList.end() && !found){
          if(  isin.find_first_of((*iterExchange)["CountryISO2"].get<std::string>())==0 
            || isin.find_first_of((*iterExchange)["CountryISO3"].get<std::string>())==0){
            currency =   (*iterExchange)["Currency"].get<std::string>();
            found=true;
          }
          ++iterExchange;
        }
      }
      
      if(currency.length()==0){
        //Retrieve the currency_symbol which appears in the 
        //BalanceSheet        
        JsonFunctions::getJsonString(iterScan["currency_symbol"],currency);
      }


      bool appendNewCurrencyData=true;

      //Add a condition here to append the exchanges that corresponds to
      //the leading digits of the ISIN number
      
      //Scan through the list of existing patches to see if the currency
      //appears in this list or not.
      for(auto& iterPatch : primaryTickerPatchDataVector){
        //If the currency exists, then add to the existing patch
        if( iterPatch.currency.compare(currency)==0){
          appendNewCurrencyData=false;
          std::string code;
          JsonFunctions::getJsonString(iterScan["Code"],code);            
          iterPatch.tickersInError.push_back(code);
          iterPatch.patchFound.push_back(false);          
        }
      }

      //If the currency doesn't appear in the list of tickers to patch, 
      //then make a new entry
      if(appendNewCurrencyData){
        primaryTickerPatchData patch;
        patch.currency = currency;

        std::string code;
        JsonFunctions::getJsonString(iterScan["Code"],code);            
        patch.tickersInError.push_back(code);
        patch.patchFound.push_back(false);

        //Make a list that contains every exchange that uses this currency
        for(auto& iterExchange : exchangeList){
          std::string exchangeCurrency;
          JsonFunctions::getJsonString(iterExchange["Currency"],exchangeCurrency);
            if(patch.currency.compare(exchangeCurrency)==0){
              std::string exchangeCode;
              JsonFunctions::getJsonString(iterExchange["Code"],exchangeCode);
              patch.exchanges.push_back(exchangeCode);
            }
        }
        primaryTickerPatchDataVector.push_back(patch);
      }
    }
  }

  unsigned int numElementsToProcess=0;
  for(auto& iterPatch : primaryTickerPatchDataVector){
    numElementsToProcess += 
      iterPatch.tickersInError.size()*iterPatch.exchanges.size();
  }


  //The data in primaryTickerPatchDataVector has been organized so that
  //the file for a specific exchange only needs to be opened once to 
  //reduce the run time.
  if(verbose){
    std::cout << "Processing "  << std::endl;
  }
  unsigned int tickerCount = 0;
  for (auto& iterPatch : primaryTickerPatchDataVector){

    for (auto& iterExchange : iterPatch.exchanges ){
      //load the exchange-symbol-list
      std::string exchangeSymbolListPath = exchangeSymbolListFolder;
      exchangeSymbolListPath.append(iterExchange);
      exchangeSymbolListPath.append(".json");
      std::ifstream exchangeSymbolListFileStream(exchangeSymbolListPath);
      json exchangeSymbolList = json::parse(exchangeSymbolListFileStream);        

      //for(auto& indexTicker : iterPatch.tickersInError){
      for(unsigned int indexTicker=0; 
            indexTicker<iterPatch.tickersInError.size();  ++indexTicker){

        ++tickerCount;

        //Get the code, isin, name
        std::string code = iterPatch.tickersInError[indexTicker];
        std::string isin = patchResults[code]["ISIN"].get<std::string>();
        std::string nameARaw;
        JsonFunctions::getJsonString(scanResults[code]["Name"],nameARaw);


        if(verbose){
          std::cout << tickerCount << '\t' <<"/" << numElementsToProcess << std::endl;
          std::cout << '\t' << code << std::endl;
          std::cout << '\t' << nameARaw << std::endl;
          std::cout << '\t' << isin << std::endl;
          std::cout << std::endl;
        }        


        //If the ISIN exists, go see if you can find an entry that corresponds
        //in one of the exchanges
        std::assert(0);
        std:abort();

        bool isinMatchFound=false;
        if(isin.length()>0){
          auto iterSymbol=exchangeSymbolList.begin();
          bool found=false;

          std::string candidateIsin("");
          JsonFunctions::getJsonString((*iterSymbol)["Isin"],candidateIsin);

          while(iterSymbol != exchangeSymbolList.end() && !found){
            if(  isin.compare(candidateIsin)==0){
              patchResults[code]["PatchFound"] = true;
              patchResults[code]["PatchISIN"]                 = isin;
              patchResults[code]["PatchNameSimilarityScore"]  = 1.0;
              patchResults[code]["PatchISINExactMatch"]       = true;

              patchResults[code]["PatchPrimaryTicker"]        = 
                (*iterSymbol)["Code"].get<std::string>();

              patchResults[code]["PatchPrimaryExchange"]      = 
                (*iterSymbol)["Exchange"].get<std::string>();

              patchResults[code]["PatchName"]                 = 
                (*iterSymbol)["Name"].get<std::string>();          

              found=true;
              isinMatchFound=true;
            }
            ++iterSymbol;
          }
        }

        //If the ISIN search failed, try to find a company that exists with
        //a similar name
        if(isinMatchFound==false){
          StringToolkit::WordData wordA(nameARaw);

          //Calculate the minimum acceptable score
          bool candidateFound = false;
          double bestScore    = 
            patchResults[code]["PatchNameSimilarityScore"].get<double>();

          std::string bestName;
          std::string bestCode;
          std::string bestIsin;

          for(auto& iterSymbol : exchangeSymbolList){

    
            std::string nameBRaw;
            JsonFunctions::getJsonString(iterSymbol["Name"],nameBRaw);
            StringToolkit::TextData textB(nameBRaw);

            StringToolkit::TextSimilarity simAB;

            simAB.score=0;
            simAB.firstWordsMatch=false;
            simAB.allWordsFound=false;
            simAB.exactMatch=false;

            StringToolkit::evaluateSimilarity(wordA,textB,simAB);

            if( ( simAB.score > bestScore &&
                  simAB.score > MIN_MATCHING_WORD_FRACTION)  ||
                ( simAB.exactMatch)) {
  
              bestScore=simAB.score;
              candidateFound=true;
              JsonFunctions::getJsonString(iterSymbol["Name"],bestName);            
              JsonFunctions::getJsonString(iterSymbol["Code"],bestCode);
              JsonFunctions::getJsonString(iterSymbol["ISIN"],bestIsin);

              //The spelling of ISIN in the json files is not always consistent      
              if(bestIsin.length()==0){
                JsonFunctions::getJsonString(iterSymbol["Isin"], bestIsin);
              }
              if(bestIsin.length()==0){
                JsonFunctions::getJsonString(iterSymbol["isin"], bestIsin);
              }
              

              //bestCode.append(".");
              //bestCode.append(iterExchange);

              patchResults[code]["PatchFound"] = true;
              patchResults[code]["PatchPrimaryTicker"]    = bestCode;
              patchResults[code]["PatchPrimaryExchange"]  = iterExchange;
              patchResults[code]["PatchName"]=bestName;
              patchResults[code]["PatchISIN"]=bestIsin;
              patchResults[code]["PatchNameSimilarityScore"] = bestScore;

              iterPatch.patchFound[indexTicker]=true;

              if(simAB.exactMatch){
                patchResults[code]["PatchNameExactMatch"]=true;
                break;
              }
            }else if( simAB.score > 
              patchResults[code]["PatchNameSimilarityScoreClosest"].get<double>()){
              std::string secondCode,secondName,secondIsin;
              JsonFunctions::getJsonString(iterSymbol["Name"],secondName);            
              JsonFunctions::getJsonString(iterSymbol["Code"],secondCode);            
              JsonFunctions::getJsonString(iterSymbol["ISIN"],secondIsin);

              if(secondIsin.length()==0){
                JsonFunctions::getJsonString(iterSymbol["Isin"], secondIsin);
              }
              if(secondIsin.length()==0){
                JsonFunctions::getJsonString(iterSymbol["isin"], secondIsin);
              }

              patchResults[code]["PatchNameClosest"]=secondName;
              patchResults[code]["PatchCodeClosest"]=secondCode;
              patchResults[code]["PatchExchangeClosest"]=iterExchange;
              patchResults[code]["PatchISINClosest"]=secondIsin;
              patchResults[code]["PatchNameSimilarityScoreClosest"] = simAB.score;
            } 
          }
        }

      }

    }
  }

  //Split patchResults into:
  // patch.json            : exact match
  // patch.candidate.json  : not exact, but met the conditions
  // patch.missing.json    : did not meet conditions

json patchIsinMatchList;
json patchNameMatchList;
json patchNameSimilarList;
json patchMissingList;

for(auto& iterPatch : patchResults){
  bool isinFound  = iterPatch["PatchISINExactMatch"].get<bool>();
  bool patchFound = iterPatch["PatchFound"].get<bool>();
  bool patchExact = iterPatch["PatchNameExactMatch"].get<bool>();
  std::string code;
  JsonFunctions::getJsonString(iterPatch["Code"],code);        
  if(isinFound){
    json patchIsinMatchEntry=
      json::object( 
          { 
            {"Name", iterPatch["Name"].get<std::string>()},
            {"Code", iterPatch["Code"].get<std::string>()},
            {"Exchange", iterPatch["Exchange"].get<std::string>()},
            {"ISIN", iterPatch["ISIN"].get<std::string>()},            
            {"PatchName",iterPatch["PatchName"]},                   
            {"PatchISIN", iterPatch["PatchISIN"].get<std::string>()},            
            {"PrimaryTicker", iterPatch["PatchPrimaryTicker"].get<std::string>()},
            {"PrimaryExchange", iterPatch["PatchPrimaryExchange"].get<std::string>()},            
          }
        );
    patchIsinMatchList[code]=patchIsinMatchEntry; 
  }else if(patchExact){
    json patchExactEntry = 
      json::object( 
          { 
            {"Name", iterPatch["Name"].get<std::string>()},
            {"Code", iterPatch["Code"].get<std::string>()},
            {"Exchange", iterPatch["Exchange"].get<std::string>()},
            {"ISIN", iterPatch["ISIN"].get<std::string>()},            
            {"PatchName",iterPatch["PatchName"]},            
            {"PatchISIN", iterPatch["PatchISIN"].get<std::string>()},            
            {"PrimaryTicker", iterPatch["PatchPrimaryTicker"].get<std::string>()},
            {"PrimaryExchange", iterPatch["PatchPrimaryExchange"].get<std::string>()},            
          }
        );
    patchNameMatchList[code]=patchExactEntry;  
  }else if(!patchExact && patchFound){
    json patchCandidateEntry = 
      json::object( 
          { 
            {"Name", iterPatch["Name"].get<std::string>()},
            {"Code", iterPatch["Code"].get<std::string>()},
            {"Exchange", iterPatch["Exchange"].get<std::string>()},
            {"ISIN", iterPatch["ISIN"].get<std::string>()},            
            {"PatchName",iterPatch["PatchName"]},
            {"PatchISIN", iterPatch["PatchISIN"].get<std::string>()},            
            {"PrimaryTicker", iterPatch["PatchPrimaryTicker"].get<std::string>()},
            {"PrimaryExchange", iterPatch["PatchPrimaryExchange"].get<std::string>()},            
            {"PatchNameSimilarityScore", iterPatch["PatchNameSimilarityScore"].get<double>()},
          }
        );
    patchNameSimilarList[code]=patchCandidateEntry;  

  }else{
//  if(!patchExact && !patchFound){

    std::string patchNameClosest;
    std::string patchCodeClosest;
    std::string patchExchangeClosest;
    std::string patchIsinClosest;
    double patchSimilarityScoreClosest=0;
    JsonFunctions::getJsonString(iterPatch["PatchNameClosest"],patchNameClosest);
    JsonFunctions::getJsonString(iterPatch["PatchCodeClosest"],patchCodeClosest);
    JsonFunctions::getJsonString(iterPatch["PatchExchangeClosest"],patchExchangeClosest);
    JsonFunctions::getJsonString(iterPatch["PatchISINClosest"],patchIsinClosest);
    patchSimilarityScoreClosest= 
      JsonFunctions::getJsonFloat( iterPatch["PatchNameSimilarityScoreClosest"]);

    json patchMissingEntry = 
      json::object( 
          { 
            {"Name", iterPatch["Name"].get<std::string>()},
            {"Code", iterPatch["Code"].get<std::string>()},
            {"Exchange", iterPatch["Exchange"].get<std::string>()},
            {"ISIN", iterPatch["ISIN"].get<std::string>()},
            {"PatchNameClosest", patchNameClosest},
            {"PatchCodeClosest", patchCodeClosest},
            {"PatchExchangeClosest",patchExchangeClosest},    
            {"PatchISINClosest",patchIsinClosest},        
            {"PatchNameSimilarityScoreClosest", patchSimilarityScoreClosest},
          }
        );
    patchMissingList[code]=patchMissingEntry;  
  }



  }

  //Report on the items that were patched and not.
  if(verbose){
    std::cout << std::endl;    
    std::cout << "Patches found with matching ISIN numbers : " << std::endl;
    std::cout << std::endl;

    unsigned int count = 1;
    for(auto& iterPatch : patchIsinMatchList){
      std::cout << count << "." << '\t' 
                << iterPatch["Code"].get<std::string>() << '\t' << '\t'   
                << iterPatch["Name"].get<std::string>() << std::endl
                << '\t' << iterPatch["PrimaryTicker"].get<std::string>() 
        << '\t' << '\t' << iterPatch["PatchName"].get<std::string>() << std::endl;
      std::cout << std::endl;

      ++count;
    }


    std::cout << std::endl;    
    std::cout << "Patches found with matching names : " << std::endl;
    std::cout << std::endl;

    count = 1;
    for(auto& iterPatch : patchNameMatchList){
      std::cout << count << "." << '\t' 
                << iterPatch["Code"].get<std::string>() << '\t' << '\t'   
                << iterPatch["Name"].get<std::string>() << std::endl
                << '\t' << iterPatch["PrimaryTicker"].get<std::string>() 
        << '\t' << '\t' << iterPatch["PatchName"].get<std::string>() << std::endl;
      std::cout << std::endl;

      ++count;
    }

    std::cout << std::endl;    
    std::cout << "Patches found with similar names : " << std::endl;
    std::cout << std::endl;

    count =1;
    for(auto& iterPatch : patchNameSimilarList){
      std::cout << count << "." << '\t' 
                << iterPatch["Code"].get<std::string>() << '\t' 
                << iterPatch["PrimaryTicker"].get<std::string>() << std::endl
                << '\t' << iterPatch["Name"].get<std::string>() << std::endl                
                << '\t' << iterPatch["PatchName"].get<std::string>() << std::endl;

      std::cout << '\t' << iterPatch["PatchNameSimilarityScore"].get<double>() 
                << std::endl << std::endl;
      ++count;
    }


    std::cout << std::endl;    
    std::cout << "Patch missing for : " << std::endl;
    std::cout << std::endl;

    count =1;
    for(auto& iterPatch : patchMissingList){
      std::cout << count << "." << '\t' 
                << iterPatch["Code"].get<std::string>() << std::endl  
                << '\t' << iterPatch["Name"].get<std::string>() << std::endl
                << '\t' << iterPatch["PatchNameClosest"].get<std::string>() << std::endl
                << '\t' << iterPatch["PatchNameSimilarityScoreClosest"].get<double>();                 
      std::cout << std::endl;
      std::cout << std::endl;
      ++count;
    }

  }
    
  //Output the list of matching isin patches
  std::string outputFilePath(outputFolder);
  std::string outputFileName(exchangeCode);
  outputFileName.append(".patch.matching_isin.json");
  outputFilePath.append(outputFileName);

  std::ofstream outputFileStream(outputFilePath,
      std::ios_base::trunc | std::ios_base::out);
  outputFileStream << patchIsinMatchList;
  outputFileStream.close();


  //Output the list of matching by name patches
  outputFilePath = outputFolder;
  outputFileName = exchangeCode;
  outputFileName.append(".patch.matching_name.json");
  outputFilePath.append(outputFileName);

  outputFileStream.open(outputFilePath,
      std::ios_base::trunc | std::ios_base::out);
  outputFileStream << patchNameMatchList;
  outputFileStream.close();

  //Output the list of candidate patches
  outputFilePath = outputFolder;
  outputFileName = exchangeCode;
  outputFileName.append(".patch.candidate.json");
  outputFilePath.append(outputFileName);

  outputFileStream.open(outputFilePath,
      std::ios_base::trunc | std::ios_base::out);
  outputFileStream << patchNameSimilarList;
  outputFileStream.close();

  //Output the list of missing patches
  outputFilePath = outputFolder;
  outputFileName = exchangeCode;
  outputFileName.append(".patch.missing.json");
  outputFilePath.append(outputFileName);

  outputFileStream.open(outputFilePath,
      std::ios_base::trunc | std::ios_base::out);
  outputFileStream << patchMissingList;
  outputFileStream.close();


  std::cout << "success" << std::endl;

  return 0;
}
